# Gallo Connect - SAP Commerce Composable Storefront Cursor Rules

## Project Overview
This is an Angular v19 application built on the SAP Commerce Spartacus Composable Storefront framework (version 2211.43.0). Spartacus provides a lean, Angular-based JavaScript storefront that communicates exclusively through the SAP Commerce Cloud REST API.

## Core Technologies
- Angular 19.2.0 (not standalone components - uses NgModule architecture)
- Spartacus Composable Storefront 2211.43.0 
- TypeScript 5.7.2
- SCSS for styling
- NgRx for state management (@ngrx/store, @ngrx/effects, @ngrx/router-store)
- Angular OAuth2 OIDC for authentication
- Font Awesome 6.7.2 for icons

## Architecture Principles

### 1. Spartacus Module Structure
- **Main Module**: `SpartacusModule` orchestrates the entire storefront
- **Configuration Module**: `SpartacusConfigurationModule` handles backend OCC configuration, site context, i18n, and feature flags
- **Features Module**: `SpartacusFeaturesModule` imports all feature-specific modules and storefront components
- **Feature Modules**: Individual modules for cart, checkout, user, organization, etc.

### 2. Feature Module Pattern
Each Spartacus feature follows this pattern:
```typescript
@NgModule({
  imports: [FeatureRootModule],
  providers: [
    provideConfig(<CmsConfig>{
      featureModules: {
        [FEATURE_NAME]: {
          module: () => import('@spartacus/feature/path').then(m => m.FeatureModule)
        }
      }
    }),
    provideConfig(<I18nConfig>{
      i18n: {
        resources: { en: featureTranslations },
        chunks: featureTranslationChunks
      }
    })
  ]
})
export class FeatureModule {}
```

### 3. Angular v19 Best Practices
- Use constructor-based dependency injection for services
- Leverage `inject()` function when appropriate for newer patterns
- Use `@Injectable({ providedIn: 'root' })` for singleton services
- Follow reactive patterns with RxJS observables
- Use Angular's new control flow syntax where beneficial

## Development Guidelines

### 1. Component Development
```typescript
// Preferred component structure
@Component({
  selector: 'app-custom-component',
  templateUrl: './custom-component.component.html',
  styleUrls: ['./custom-component.component.scss'],
  standalone: false // This project uses NgModule architecture
})
export class CustomComponent implements OnInit {
  // Use constructor injection for services
  constructor(
    private spartacusService: SomeService,
    private customService: CustomService
  ) {}

  ngOnInit(): void {
    // Initialization logic
  }
}
```

### 2. Service Development
```typescript
@Injectable({
  providedIn: 'root'
})
export class CustomService {
  constructor(
    private http: HttpClient,
    private configService: ConfigService
  ) {}
  
  // Use observables for async operations
  getData(): Observable<any> {
    return this.http.get('/api/data');
  }
}
```

### 3. Spartacus Extension Patterns

#### Extending Spartacus Components
```typescript
// Extend existing Spartacus components
@Component({
  selector: 'cx-custom-product-intro',
  templateUrl: './custom-product-intro.component.html'
})
export class CustomProductIntroComponent extends ProductIntroComponent {
  // Add custom functionality while maintaining Spartacus base behavior
}
```

#### Custom CMS Components
```typescript
@Component({
  selector: 'cx-custom-banner',
  template: `<div class="custom-banner">{{ content?.headline }}</div>`
})
export class CustomBannerComponent implements CmsComponentData<CustomBannerModel> {
  @Input() component: CustomBannerModel;
}
```

### 4. Configuration Extensions
```typescript
// Extend Spartacus configuration
export const customConfig: Config = {
  backend: {
    occ: {
      baseUrl: 'https://localhost:9002',
      prefix: '/occ/v2/'
    }
  },
  context: {
    baseSite: ['powertools-spa'],
    currency: ['USD'],
    language: ['en']
  },
  features: {
    level: '2211.43'
  }
};
```

### 5. Styling Guidelines
- Use SCSS for all styling
- Follow Spartacus theming patterns
- Leverage CSS custom properties for dynamic styling
- Place feature-specific styles in `src/styles/spartacus/` directory
- Import styles in `angular.json` build configuration

```scss
// Feature-specific styling
.custom-component {
  --cx-color-primary: #{$cx-color-primary};
  
  .custom-element {
    background-color: var(--cx-color-primary);
    padding: 1rem;
  }
}
```

## Available Spartacus Features
This application includes the following Spartacus features:
- **Cart**: Base cart, saved cart, wish list, quick order, import/export
- **Checkout**: Full checkout flow with B2B payment types
- **User**: Account management, profile, authentication
- **Organization**: B2B administration, user registration, order approval, unit orders, account summary
- **Product**: Variants, bulk pricing, future stock, image zoom
- **Order**: Order history and management
- **ASM**: Assisted Service Module with Customer 360
- **Store Finder**: Store localization features
- **Tracking**: Personalization features
- **SmartEdit**: CMS integration
- **PDF Invoices**: Invoice generation
- **Estimated/Requested Delivery Date**: Delivery date management

## File Organization Rules

### 1. Feature Module Structure
```
src/app/spartacus/features/
├── [feature-name]/
│   ├── [feature-name]-feature.module.ts
│   ├── [feature-name]-wrapper.module.ts (if needed)
│   └── components/ (for custom components)
```

### 2. Styling Structure
```
src/styles/spartacus/
├── [feature-name].scss
└── _index.scss (imports all feature styles)
```

### 3. Custom Components
```
src/app/
├── components/
│   └── [component-category]/
│       └── [component-name]/
└── services/
    └── [service-name].service.ts
```

## Code Quality Standards

### 1. TypeScript
- Use strict TypeScript configuration
- Implement proper interfaces for all data models
- Use generics where appropriate
- Follow Angular naming conventions

### 2. Testing
- Write unit tests for all custom components and services
- Use Jasmine and Karma for testing
- Mock Spartacus services in tests
- Aim for >90% code coverage

### 3. Accessibility
- Follow WCAG 2.1 AA guidelines
- Use semantic HTML elements
- Implement proper ARIA attributes
- Test with screen readers

### 4. Performance
- Lazy load feature modules where possible
- Use OnPush change detection strategy when appropriate
- Optimize bundle sizes with tree shaking
- Implement proper caching strategies

## Extension Patterns

### 1. Outlet-based Extensions
```typescript
// Use Spartacus outlets for content injection
<ng-container *cxOutlet="'ProductIntro.description'">
  <custom-product-description></custom-product-description>
</ng-container>
```

### 2. Configuration-based Extensions
```typescript
// Override default configurations
providers: [
  provideConfig(<LayoutConfig>{
    layoutSlots: {
      ProductDetailsPageTemplate: {
        sections: ['ProductIntro', 'ProductDetails', 'CustomSection']
      }
    }
  })
]
```

### 3. Service Extensions
```typescript
// Extend Spartacus services
@Injectable()
export class CustomProductService extends ProductService {
  // Override or extend methods
  getProductDetails(code: string): Observable<Product> {
    // Custom implementation
    return super.getProductDetails(code);
  }
}
```

## Common Patterns to Avoid

### 1. Direct DOM Manipulation
- Never manipulate DOM directly
- Use Angular's ViewChild and ViewRef when needed
- Leverage Angular's rendering capabilities

### 2. Breaking Spartacus Contracts
- Don't modify core Spartacus files directly
- Use extension patterns instead of forking
- Respect Spartacus's lazy loading architecture

### 3. Performance Anti-patterns
- Avoid unnecessary subscriptions
- Don't forget to unsubscribe from observables
- Use async pipe where possible
- Avoid heavy computations in templates

## Integration Guidelines

### 1. Backend Integration
- All backend communication goes through SAP Commerce Cloud OCC REST API
- Use Spartacus facades for state management
- Implement proper error handling for API calls

### 2. Third-party Integrations
- Use Angular's HTTP interceptors for cross-cutting concerns
- Implement proper loading states
- Handle authentication tokens correctly

### 3. Custom API Integration
```typescript
@Injectable()
export class CustomApiService {
  constructor(
    private http: HttpClient,
    private occEndpoints: OccEndpointsService
  ) {}
  
  customApiCall(): Observable<any> {
    const url = this.occEndpoints.buildUrl('customEndpoint');
    return this.http.get(url);
  }
}
```

## Security Considerations
- Use Angular's built-in XSS protection
- Implement CSRF protection
- Validate all user inputs
- Use HTTPS for all communications
- Follow OAuth2/OIDC best practices

## Debugging and Development Tools
- Use Angular DevTools for debugging
- Leverage Spartacus's debug mode
- Use browser dev tools for performance profiling
- Implement proper logging with different levels

## Feature Flags and Configuration
The application uses extensive feature flags for A11y improvements, performance optimizations, and behavior modifications. Always check existing feature flags before implementing new functionality.

## Migration Considerations
- This application is on Spartacus 2211.43.0
- Follow Spartacus migration guides for updates
- Test all customizations after Spartacus updates
- Maintain compatibility with SAP Commerce Cloud backend

Remember: Spartacus is a framework, not a library. Follow its patterns and extension points rather than working against them.
